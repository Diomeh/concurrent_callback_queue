<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"ConcurrentCallbackQueue.js.html":{"id":"ConcurrentCallbackQueue.js.html","title":"Source: ConcurrentCallbackQueue.js","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions Source: ConcurrentCallbackQueue.js // noinspection JSUnusedGlobalSymbols /** * Opciones de configuración de la cola * * @typedef {Object} QueueOptions * @property {boolean} autoStart - Indica si la cola debe iniciar su ejecución automáticamente al agregar un callback * @property {number} maxConcurrent - Cantidad máxima de callbacks que se pueden ejecutar en paralelo * @property {Function} onCallbackError - Callback que se ejecuta cuando ocurre un error al ejecutar un callback, recibe como * parámetro el error que se produjo * @property {Function} onCallbackSuccess - Callback que se ejecuta después de que un callback se ejecuta correctamente * @property {Function} onQueueIdle - Callback que se ejecuta cuando la cola pasa a estado IDLE * @property {Function} onQueueBusy - Callback que se ejecuta cuando la cola pasa a estado BUSY * @property {Function} onQueueStop - Callback que se ejecuta cuando la cola se detiene */ /** * Opciones por defecto de la cola * * @type {QueueOptions} */ const defaultQueueOptions = { autoStart: true, maxConcurrent: 10, onCallbackError: null, onCallbackSuccess: null, onQueueIdle: null, onQueueBusy: null, onQueueStop: null, }; /** * Enumera los estados en que se puede encontrar la cola * * @type {{IDLE: string, BUSY: string, STOPPED: string}} */ const QueueState = { IDLE: 'IDLE', BUSY: 'BUSY', STOPPED: 'STOPPED', }; /** * Cola de callbacks que se ejecutan de forma concurrente * * @class ConcurrentCallbackQueue * @example * const queue = new ConcurrentCallbackQueue({ * autoStart: false, * maxConcurrent: 2, * onCallbackError: (error) =&gt; console.error(error), * }); * * for (let i = 0; i &lt; 10; i++) { * queue.enqueue(() =&gt; { * const uri = 'https://httpstat.us/200,400?sleep=2000'; * return $.get(uri).done(() =&gt; { * console.log(`Request ${i+1} completed`); * }); * }, 3); * } * * queue.start(); * * @author David Urbina * @version 1.0.0 * @since 2023-03-23 */ class ConcurrentCallbackQueue { /** * Cola de callbacks pendientes a ejecutar de forma concurrente * * @type {Array&lt;Function&gt;} * @private */ #pending; /** * Callbacks en ejecución * * @type {Map&lt;number, Function&gt;} * @private */ #running; /** * Estado en que se encuentra la cola * * @type {string} * @private */ #state; /** * Cantidad de callbacks que se están ejecutando en este momento * * @type {number} * @private */ #concurrent; /** * Opciones de configuración de la cola * * @type {QueueOptions} * @private */ #options; /** * Crea una nueva cola de callbacks concurrentes. * * @param {QueueOptions} options - Opciones de configuración de la cola. */ constructor(options = defaultQueueOptions) { this.#pending = []; this.#running = new Map(); this.#state = QueueState.IDLE; this.#concurrent = 0; this.#initOptions(options); } /** * Función vacía que se usa como callback por defecto. * * @returns {void} * @private */ #noop = () =&gt; {}; /** * Inicializa las opciones de configuración de la cola, se mezclan las opciones por defecto con las opciones recibidas. * * @param {QueueOptions} options - Opciones de configuración de la cola. */ #initOptions(options) { this.#options = { ...defaultQueueOptions, ...options, }; // seteamos un noop a los callbacks que no se hayan especificado para evitar verificar si son funciones en cada llamada this.#options.onCallbackError = typeof options.onCallbackError === 'function' ? options.onCallbackError : this.#noop; this.#options.onCallbackSuccess = typeof options.onCallbackSuccess === 'function' ? options.onCallbackSuccess : this.#noop; this.#options.onQueueIdle = typeof options.onQueueIdle === 'function' ? options.onQueueIdle : this.#noop; this.#options.onQueueBusy = typeof options.onQueueBusy === 'function' ? options.onQueueBusy : this.#noop; this.#options.onQueueStop = typeof options.onQueueStop === 'function' ? options.onQueueStop : this.#noop; } /** * Agrega un callback a la cola, si autoStart está activado se inicia la ejecución de la cola. * Puede especificar un número opcional de reintentos en caso de error. * * @param {Function} callback - La función de callback a agregar a la cola. * @param {number} [retries=0] - Número de intentos de reintentos en caso de error (opcional). * @returns {void} * @throws {Error} Si el callback no es una función o retries no es un número. * * @public */ enqueue(callback, retries = 0) { if (typeof callback !== 'function') { throw new Error('El callback debe ser una función') } if (typeof retries !== 'number') { throw new Error('El parámetro retries debe ser un número'); } if (retries &lt; 0) { throw new Error('El parámetro retries debe ser un número positivo'); } const retryCallback = async (currentRetry) =&gt; { try { await callback(); } catch (error) { if (currentRetry &lt; retries) { console.warn(`Error ejecutando callback. Reintentando (${currentRetry + 1}/${retries})...`); await retryCallback(currentRetry + 1); } else { this.#handleError(error); } } }; this.#pending.push(() =&gt; retryCallback(0)); if (this.#options.autoStart) { this.start(); } } /** * Agrega varios callbacks a la cola, si autoStart está activado se inicia la ejecución de la cola. * Puede especificar un número opcional de intentos de reintentos en caso de error. * * @param {Array&lt;Function&gt;} callbacks - El array de funciones de callback a agregar a la cola. * @param {number} [retries=0] - Número de intentos de reintentos en caso de error para todos los callbacks (opcional). * @returns {void} * @throws {Error} Si callbacks no es un array de funciones o retries no es un número. * * @public */ enqueueAll(callbacks, retries = 0) { if (!Array.isArray(callbacks)) { throw new Error('El parámetro debe ser un array de funciones'); } if (!callbacks.every(callback =&gt; typeof callback === 'function')) { throw new Error('El parámetro debe ser un array de funciones'); } if (typeof retries !== 'number') { throw new Error('El parámetro retries debe ser un número'); } if (retries &lt; 0) { throw new Error('El parámetro retries debe ser un número positivo'); } const retryCallbacks = callbacks.map(callback =&gt; { const retryCallback = async (currentRetry) =&gt; { try { await callback(); } catch (error) { if (currentRetry &lt; retries) { console.warn(`Error ejecutando callback. Reintentando (${currentRetry + 1}/${retries})...`); await retryCallback(currentRetry + 1); } else { this.#handleError(error); } } }; return () =&gt; retryCallback(0); }); this.#pending.push(...retryCallbacks); if (this.#options.autoStart) { this.start(); } } /** * Inicia la ejecución de la cola. * * Si en algún momento la cola es detenida y luego se vuelve a poner en marcha, * se reanuda la ejecución desde el último callback que estaba pendiente de ejecución. * * @returns {void} * @public */ start() { if (this.#state === QueueState.BUSY || this.#pending.length === 0) { return; } this.#state = QueueState.BUSY; this.#processIfNecessary(); } /** * Ejecuta de forma concurrente los callbacks de la cola. * * @returns {void} * @private */ #process() { while (this.#shouldProcess()) { const callback = this.#pending.shift(); this.#concurrent++; const index = Date.now(); this.#running.set(index, callback); Promise.resolve() .then(() =&gt; callback()) .then(() =&gt; this.#options.onCallbackSuccess()) .catch((error) =&gt; this.#handleError(error)) .finally(() =&gt; { this.#concurrent--; this.#running.delete(index); this.#processIfNecessary(); }); } // Check if the queue is now idle or busy if (this.#state === QueueState.IDLE) { this.#options.onQueueIdle(); } else if (this.#state === QueueState.BUSY) { this.#options.onQueueBusy(); } else if (this.#state === QueueState.STOPPED) { this.#options.onQueueStop(); } } /** * Maneja errores que ocurren durante la ejecución de un callback. * * @param {Error} error - El objeto de error. * @returns {void} * @private */ #handleError(error) { this.#options.onCallbackError(error); } /** * Determina si se debe procesar la cola * * @returns {boolean} Verdadero si se debe procesar la cola, falso en caso contrario * @private */ #shouldProcess() { return this.#state === QueueState.BUSY &amp;&amp; this.#concurrent &lt; this.#options.maxConcurrent &amp;&amp; this.#pending.length &gt; 0; } /** * Revisa el estado de la cola y la procesa si es necesario. * * @returns {void} * @private */ #processIfNecessary() { if (this.#state === QueueState.BUSY) { if (this.#pending.length &gt; 0) { this.#process(); } else if (this.#concurrent === 0) { this.stop(); } } } /** * Detiene la ejecución de la cola, pero no elimina los callbacks pendientes de ejecución. * * Llamar a este método no detendrá la ejecución de los callbacks que ya se están procesando, * tampoco se eliminan los callbacks pendientes de ejecución, por lo que si se vuelve * a iniciar la cola, se reanudará desde el último callback que estaba pendiente. * * @returns {void} * @public */ stop() { this.#state = QueueState.IDLE; } /** * Detiene la ejecución de la cola y elimina todos los callbacks de la misma. * * @returns {Array&lt;Function&gt;} Lista de callbacks pendientes de ejecución * @public */ clear() { this.stop(); return this.dequeueAll(); } /** * Elimina un callback pendiente de ejecución de la cola, sin detener la ejecución de la misma. * * @return {Function} Callback eliminado * @public */ dequeue() { return this.#pending.shift(); } /** * Elimina todos los callbacks pendientes de ejecución de la cola, sin detener la ejecución de la misma. * * @returns {Array&lt;Function&gt;} Lista de callbacks pendientes de ejecución * @public */ dequeueAll() { const queue = this.#pending; this.#pending = []; return queue; } /** * Devuelve el estado actual de la cola. * * @returns {string} */ getState() { return this.#state; } } × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions Global Members &lt;constant&gt; QueueState :Object Enumera los estados en que se puede encontrar la cola. Enumera los estados en que se puede encontrar la cola Type: Object Source: ConcurrentCallbackQueue.js, line 37 &lt;constant&gt; defaultQueueOptions :QueueOptions Opciones por defecto de la cola. Opciones por defecto de la cola Type: QueueOptions Source: ConcurrentCallbackQueue.js, line 22 Type Definitions QueueOptions Opciones de configuración de la cola. Opciones de configuración de la cola Type: Object Properties: Name Type Description autoStart boolean Indica si la cola debe iniciar su ejecución automáticamente al agregar un callback maxConcurrent number Cantidad máxima de callbacks que se pueden ejecutar en paralelo onCallbackError function Callback que se ejecuta cuando ocurre un error al ejecutar un callback, recibe como parámetro el error que se produjo onCallbackSuccess function Callback que se ejecuta después de que un callback se ejecuta correctamente onQueueIdle function Callback que se ejecuta cuando la cola pasa a estado IDLE onQueueBusy function Callback que se ejecuta cuando la cola pasa a estado BUSY onQueueStop function Callback que se ejecuta cuando la cola se detiene Source: ConcurrentCallbackQueue.js, line 3 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions Classes Classes ConcurrentCallbackQueue Cola de callbacks que se ejecutan de forma concurrente. ConcurrentCallbackQueue Crea una nueva cola de callbacks concurrentes. Members &lt;constant&gt; QueueState :Object Enumera los estados en que se puede encontrar la cola. Enumera los estados en que se puede encontrar la cola Type: Object Source: ConcurrentCallbackQueue.js, line 37 &lt;constant&gt; defaultQueueOptions :QueueOptions Opciones por defecto de la cola. Opciones por defecto de la cola Type: QueueOptions Source: ConcurrentCallbackQueue.js, line 22 Type Definitions QueueOptions Opciones de configuración de la cola. Opciones de configuración de la cola Type: Object Properties: Name Type Description autoStart boolean Indica si la cola debe iniciar su ejecución automáticamente al agregar un callback maxConcurrent number Cantidad máxima de callbacks que se pueden ejecutar en paralelo onCallbackError function Callback que se ejecuta cuando ocurre un error al ejecutar un callback, recibe como parámetro el error que se produjo onCallbackSuccess function Callback que se ejecuta después de que un callback se ejecuta correctamente onQueueIdle function Callback que se ejecuta cuando la cola pasa a estado IDLE onQueueBusy function Callback que se ejecuta cuando la cola pasa a estado BUSY onQueueStop function Callback que se ejecuta cuando la cola se detiene Source: ConcurrentCallbackQueue.js, line 3 × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions Tutorials Classes ConcurrentCallbackQueue Cola de callbacks que se ejecutan de forma concurrente. ConcurrentCallbackQueue Crea una nueva cola de callbacks concurrentes. Members &lt;constant&gt; QueueState :Object Enumera los estados en que se puede encontrar la cola. Enumera los estados en que se puede encontrar la cola Type: Object Source: ConcurrentCallbackQueue.js, line 37 &lt;constant&gt; defaultQueueOptions :QueueOptions Opciones por defecto de la cola. Opciones por defecto de la cola Type: QueueOptions Source: ConcurrentCallbackQueue.js, line 22 Type Definitions QueueOptions Opciones de configuración de la cola. Opciones de configuración de la cola Type: Object Properties: Name Type Description autoStart boolean Indica si la cola debe iniciar su ejecución automáticamente al agregar un callback maxConcurrent number Cantidad máxima de callbacks que se pueden ejecutar en paralelo onCallbackError function Callback que se ejecuta cuando ocurre un error al ejecutar un callback, recibe como parámetro el error que se produjo onCallbackSuccess function Callback que se ejecuta después de que un callback se ejecuta correctamente onQueueIdle function Callback que se ejecuta cuando la cola pasa a estado IDLE onQueueBusy function Callback que se ejecuta cuando la cola pasa a estado BUSY onQueueStop function Callback que se ejecuta cuando la cola se detiene Source: ConcurrentCallbackQueue.js, line 3 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions concurrent_callback_queue 0.8.0 Concurrent Callback Queue This JavaScript module provides a concurrent callback queue that allows you to manage and execute multiple callbacks concurrently with various configuration options. The queue ensures controlled execution of the callbacks with options for handling errors, managing concurrency levels, and defining custom behavior on different queue states. Features Concurrent Execution: Execute multiple callbacks concurrently with a configurable limit on the number of concurrent executions. Automatic Start: Option to automatically start the queue execution upon adding a callback. Retry Mechanism: Define the number of retry attempts for each callback in case of errors. State Management: Callbacks for different queue states (idle, busy, stopped) and events (success, error). Custom Callbacks: Customize behavior on callback success, error, and different queue states. Installation To use the ConcurrentCallbackQueue, you can directly include the JavaScript file in your project. &lt;script src=\"path/to/ConcurrentCallbackQueue.js\"&gt;&lt;/script&gt; Or, if you're using a module bundler, you can import it: import ConcurrentCallbackQueue from './path/to/ConcurrentCallbackQueue.js'; Usage Example Here's an example of how to use the ConcurrentCallbackQueue: const queue = new ConcurrentCallbackQueue({ autoStart: false, maxConcurrent: 2, onCallbackError: (error) =&gt; console.error(error), }); for (let i = 0; i &lt; 10; i++) { queue.enqueue(() =&gt; { const uri = 'https://httpstat.us/200,400?sleep=2000'; return $.get(uri).done(() =&gt; { console.log(`Request ${i+1} completed`); }); }, 3); } queue.start(); More detailed examples can be found in the tutorial page. Configuration Options The queue can be configured with the following options: autoStart (boolean): Whether to start the queue automatically when a callback is added. maxConcurrent (number): Maximum number of callbacks to execute concurrently. onCallbackError (function): Callback executed when an error occurs during callback execution. onCallbackSuccess (function): Callback executed after a callback is executed successfully. onQueueIdle (function): Callback executed when the queue becomes idle. onQueueBusy (function): Callback executed when the queue becomes busy. onQueueStop (function): Callback executed when the queue stops. API enqueue(callback, retries = 0) Adds a callback to the queue. If autoStart is enabled, it starts the queue. callback (function): The callback function to be added to the queue. retries (number, optional): Number of retry attempts in case of error. enqueueAll(callbacks, retries = 0) Adds multiple callbacks to the queue. If autoStart is enabled, it starts the queue. callbacks (Array): An array of callback functions to be added to the queue. retries (number, optional): Number of retry attempts for all callbacks in case of error. start() Starts the execution of the queue. Resumes execution if the queue was stopped. stop() Stops the execution of the queue without clearing the pending callbacks. clear() Stops the execution of the queue and clears all pending callbacks. dequeue() Removes a pending callback from the queue without stopping the queue execution. dequeueAll() Removes all pending callbacks from the queue without stopping the queue execution. getState() Returns the current state of the queue. Queue States IDLE: The queue is idle. BUSY: The queue is busy executing callbacks. STOPPED: The queue is stopped. License This project is licensed under the MIT License. Author David Urbina × Search results Close "},"ConcurrentCallbackQueue.html":{"id":"ConcurrentCallbackQueue.html","title":"Class: ConcurrentCallbackQueue","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions Class: ConcurrentCallbackQueue ConcurrentCallbackQueue new ConcurrentCallbackQueue() Cola de callbacks que se ejecutan de forma concurrente. Cola de callbacks que se ejecutan de forma concurrente Version: 1.0.0 Since: 2023-03-23 Author: David Urbina Source: ConcurrentCallbackQueue.js, line 43 Example const queue = new ConcurrentCallbackQueue({ autoStart: false, maxConcurrent: 2, onCallbackError: (error) =&gt; console.error(error), }); for (let i = 0; i &lt; 10; i++) { queue.enqueue(() =&gt; { const uri = 'https://httpstat.us/200,400?sleep=2000'; return $.get(uri).done(() =&gt; { console.log(`Request ${i+1} completed`); }); }, 3); } queue.start(); Methods clear() Detiene la ejecución de la cola y elimina todos los callbacks de la misma. Detiene la ejecución de la cola y elimina todos los callbacks de la misma. Source: ConcurrentCallbackQueue.js, line 354 Returns: Lista de callbacks pendientes de ejecución Type Array.&lt;function()&gt; dequeue() Elimina un callback pendiente de ejecución de la cola, sin detener la ejecución de la misma. Elimina un callback pendiente de ejecución de la cola, sin detener la ejecución de la misma. Source: ConcurrentCallbackQueue.js, line 365 Returns: Callback eliminado Type function dequeueAll() Elimina todos los callbacks pendientes de ejecución de la cola, sin detener la ejecución de la misma. Elimina todos los callbacks pendientes de ejecución de la cola, sin detener la ejecución de la misma. Source: ConcurrentCallbackQueue.js, line 375 Returns: Lista de callbacks pendientes de ejecución Type Array.&lt;function()&gt; enqueue(callback [, retries]) Agrega un callback a la cola, si autoStart está activado se inicia la ejecución de la cola. Agrega un callback a la cola, si autoStart está activado se inicia la ejecución de la cola. Puede especificar un número opcional de reintentos en caso de error. Parameters: Name Type Argument Default Description callback function La función de callback a agregar a la cola. retries number &lt;optional&gt; 0 Número de intentos de reintentos en caso de error (opcional). Source: ConcurrentCallbackQueue.js, line 161 Throws: Si el callback no es una función o retries no es un número. Type Error Returns: Type void enqueueAll(callbacks [, retries]) Agrega varios callbacks a la cola, si autoStart está activado se inicia la ejecución de la cola. Agrega varios callbacks a la cola, si autoStart está activado se inicia la ejecución de la cola. Puede especificar un número opcional de intentos de reintentos en caso de error. Parameters: Name Type Argument Default Description callbacks Array.&lt;function()&gt; El array de funciones de callback a agregar a la cola. retries number &lt;optional&gt; 0 Número de intentos de reintentos en caso de error para todos los callbacks (opcional). Source: ConcurrentCallbackQueue.js, line 203 Throws: Si callbacks no es un array de funciones o retries no es un número. Type Error Returns: Type void getState() Devuelve el estado actual de la cola. Devuelve el estado actual de la cola. Source: ConcurrentCallbackQueue.js, line 386 Returns: Type string start() Inicia la ejecución de la cola. Inicia la ejecución de la cola. Si en algún momento la cola es detenida y luego se vuelve a poner en marcha, se reanuda la ejecución desde el último callback que estaba pendiente de ejecución. Source: ConcurrentCallbackQueue.js, line 252 Returns: Type void stop() Detiene la ejecución de la cola, pero no elimina los callbacks pendientes de ejecución. Detiene la ejecución de la cola, pero no elimina los callbacks pendientes de ejecución. Llamar a este método no detendrá la ejecución de los callbacks que ya se están procesando, tampoco se eliminan los callbacks pendientes de ejecución, por lo que si se vuelve a iniciar la cola, se reanudará desde el último callback que estaba pendiente. Source: ConcurrentCallbackQueue.js, line 344 Returns: Type void Class: ConcurrentCallbackQueue ConcurrentCallbackQueue new ConcurrentCallbackQueue(options) Crea una nueva cola de callbacks concurrentes. Crea una nueva cola de callbacks concurrentes. Parameters: Name Type Description options QueueOptions Opciones de configuración de la cola. Source: ConcurrentCallbackQueue.js, line 115 Methods clear() Detiene la ejecución de la cola y elimina todos los callbacks de la misma. Detiene la ejecución de la cola y elimina todos los callbacks de la misma. Source: ConcurrentCallbackQueue.js, line 354 Returns: Lista de callbacks pendientes de ejecución Type Array.&lt;function()&gt; dequeue() Elimina un callback pendiente de ejecución de la cola, sin detener la ejecución de la misma. Elimina un callback pendiente de ejecución de la cola, sin detener la ejecución de la misma. Source: ConcurrentCallbackQueue.js, line 365 Returns: Callback eliminado Type function dequeueAll() Elimina todos los callbacks pendientes de ejecución de la cola, sin detener la ejecución de la misma. Elimina todos los callbacks pendientes de ejecución de la cola, sin detener la ejecución de la misma. Source: ConcurrentCallbackQueue.js, line 375 Returns: Lista de callbacks pendientes de ejecución Type Array.&lt;function()&gt; enqueue(callback [, retries]) Agrega un callback a la cola, si autoStart está activado se inicia la ejecución de la cola. Agrega un callback a la cola, si autoStart está activado se inicia la ejecución de la cola. Puede especificar un número opcional de reintentos en caso de error. Parameters: Name Type Argument Default Description callback function La función de callback a agregar a la cola. retries number &lt;optional&gt; 0 Número de intentos de reintentos en caso de error (opcional). Source: ConcurrentCallbackQueue.js, line 161 Throws: Si el callback no es una función o retries no es un número. Type Error Returns: Type void enqueueAll(callbacks [, retries]) Agrega varios callbacks a la cola, si autoStart está activado se inicia la ejecución de la cola. Agrega varios callbacks a la cola, si autoStart está activado se inicia la ejecución de la cola. Puede especificar un número opcional de intentos de reintentos en caso de error. Parameters: Name Type Argument Default Description callbacks Array.&lt;function()&gt; El array de funciones de callback a agregar a la cola. retries number &lt;optional&gt; 0 Número de intentos de reintentos en caso de error para todos los callbacks (opcional). Source: ConcurrentCallbackQueue.js, line 203 Throws: Si callbacks no es un array de funciones o retries no es un número. Type Error Returns: Type void getState() Devuelve el estado actual de la cola. Devuelve el estado actual de la cola. Source: ConcurrentCallbackQueue.js, line 386 Returns: Type string start() Inicia la ejecución de la cola. Inicia la ejecución de la cola. Si en algún momento la cola es detenida y luego se vuelve a poner en marcha, se reanuda la ejecución desde el último callback que estaba pendiente de ejecución. Source: ConcurrentCallbackQueue.js, line 252 Returns: Type void stop() Detiene la ejecución de la cola, pero no elimina los callbacks pendientes de ejecución. Detiene la ejecución de la cola, pero no elimina los callbacks pendientes de ejecución. Llamar a este método no detendrá la ejecución de los callbacks que ya se están procesando, tampoco se eliminan los callbacks pendientes de ejecución, por lo que si se vuelve a iniciar la cola, se reanudará desde el último callback que estaba pendiente. Source: ConcurrentCallbackQueue.js, line 344 Returns: Type void × Search results Close "},"tutorial-concurrent-callback-queue.html":{"id":"tutorial-concurrent-callback-queue.html","title":"Tutorial: concurrent-callback-queue","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions concurrent-callback-queue Using Concurrent Callback Queue This tutorial will guide you through the steps of using the ConcurrentCallbackQueue to manage and execute callbacks concurrently. Table of Contents Introduction Installation Basic Usage Advanced Configuration Handling Callbacks Queue Management Examples Introduction The ConcurrentCallbackQueue is a powerful utility for managing the execution of multiple callbacks concurrently. It allows you to control the number of concurrent executions, handle errors, and define custom behaviors for various queue states. Installation Script Tag You can include the ConcurrentCallbackQueue.js file directly in your HTML: &lt;script src=\"path/to/ConcurrentCallbackQueue.js\"&gt;&lt;/script&gt; Module Import If you are using a module bundler like Webpack or a module-based project setup, you can import it: import ConcurrentCallbackQueue from './path/to/ConcurrentCallbackQueue.js'; Basic Usage Creating a Queue To create a queue, simply instantiate the ConcurrentCallbackQueue class: const queue = new ConcurrentCallbackQueue(); Adding Callbacks You can add a callback to the queue using the enqueue method: queue.enqueue(() =&gt; { console.log('Callback executed'); }); Starting the Queue If autoStart is not enabled, you need to start the queue manually: queue.start(); Advanced Configuration The ConcurrentCallbackQueue class can be configured with various options during instantiation: const queue = new ConcurrentCallbackQueue({ autoStart: false, maxConcurrent: 3, onCallbackError: (error) =&gt; console.error('Error:', error), onCallbackSuccess: () =&gt; console.log('Callback succeeded'), onQueueIdle: () =&gt; console.log('Queue is idle'), onQueueBusy: () =&gt; console.log('Queue is busy'), onQueueStop: () =&gt; console.log('Queue stopped'), }); Configuration Options autoStart (boolean): Automatically start the queue when a callback is added. maxConcurrent (number): Maximum number of concurrent executions. onCallbackError (function): Function called on callback error. onCallbackSuccess (function): Function called on callback success. onQueueIdle (function): Function called when the queue is idle. onQueueBusy (function): Function called when the queue is busy. onQueueStop (function): Function called when the queue stops. Handling Callbacks Adding Callbacks with Retries You can specify the number of retries for a callback in case of errors: queue.enqueue(() =&gt; { // Callback code }, 3); Adding Multiple Callbacks You can add multiple callbacks at once using enqueueAll: const callbacks = [ () =&gt; console.log('Callback 1'), () =&gt; console.log('Callback 2'), ]; queue.enqueueAll(callbacks, 2); Queue Management Starting the Queue To start the queue manually: queue.start(); Stopping the Queue To stop the queue without clearing the pending callbacks: queue.stop(); Clearing the Queue To stop the queue and clear all pending callbacks: queue.clear(); Removing Callbacks To remove a single pending callback: queue.dequeue(); To remove all pending callbacks: queue.dequeueAll(); Examples Example 1: Basic Usage const queue = new ConcurrentCallbackQueue({ autoStart: true, maxConcurrent: 2 }); queue.enqueue(() =&gt; { console.log('Callback 1 executed'); }); queue.enqueue(() =&gt; { console.log('Callback 2 executed'); }); Example 2: Using Callbacks with Retries const queue = new ConcurrentCallbackQueue({ maxConcurrent: 1 }); queue.enqueue(() =&gt; { return new Promise((resolve, reject) =&gt; { // Simulate an async operation setTimeout(() =&gt; { console.log('Callback executed'); resolve(); }, 1000); }); }, 2); queue.start(); Example 3: Handling Callback Success and Error const queue = new ConcurrentCallbackQueue({ onCallbackSuccess: () =&gt; console.log('Callback succeeded'), onCallbackError: (error) =&gt; console.error('Error:', error), }); queue.enqueue(() =&gt; { return new Promise((resolve, reject) =&gt; { // Simulate a callback with an error setTimeout(() =&gt; { reject(new Error('Something went wrong')); }, 1000); }); }); queue.start(); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
