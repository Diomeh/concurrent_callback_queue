<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"ConcurrentCallbackQueue.js.html":{"id":"ConcurrentCallbackQueue.js.html","title":"Source: ConcurrentCallbackQueue.js","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions Source: ConcurrentCallbackQueue.js // noinspection JSUnusedGlobalSymbols /** * Queue configuration options * * @typedef {Object} QueueOptions * @property {boolean} autoStart - Indicates if the queue should start execution automatically when a callback is added * @property {number} maxConcurrent - Maximum number of callbacks that can be executed in parallel * @property {Function} onCallbackError - Callback that is executed when an error occurs while executing a callback, receives the error as a parameter * @property {Function} onCallbackSuccess - Callback that is executed after a callback successfully executes * @property {Function} onQueueIdle - Callback that is executed when the queue goes to IDLE state * @property {Function} onQueueBusy - Callback that is executed when the queue goes to BUSY state * @property {Function} onQueueStop - Callback that is executed when the queue stops */ /** * Default queue options * * @type {QueueOptions} */ const defaultQueueOptions = { autoStart: true, maxConcurrent: 10, onCallbackError: null, onCallbackSuccess: null, onQueueIdle: null, onQueueBusy: null, onQueueStop: null, }; /** * Enumerates the states the queue can be in * * @type {{IDLE: string, BUSY: string, STOPPED: string}} */ const QueueState = { IDLE: 'IDLE', BUSY: 'BUSY', STOPPED: 'STOPPED', }; /** * Concurrent callback queue * * @class ConcurrentCallbackQueue * @example * const queue = new ConcurrentCallbackQueue({ * autoStart: false, * maxConcurrent: 2, * onCallbackError: (error) =&gt; console.error(error), * }); * * for (let i = 0; i &lt; 10; i++) { * queue.enqueue(() =&gt; { * const uri = 'https://httpstat.us/200,400?sleep=2000'; * return $.get(uri).done(() =&gt; { * console.log(`Request ${i+1} completed`); * }); * }, 3); * } * * queue.start(); * * @author David Urbina (davidurbina.dev@gmail.com) * @version 0.8.0 * @since 2023-03-23 * @tutorial concurrent-callback-queue */ class ConcurrentCallbackQueue { /** * List of pending callbacks to execute concurrently * * @type {Array&lt;Function&gt;} * @private */ #pending; /** * Callbacks currently running * * @type {Map&lt;number, Function&gt;} * @private */ #running; /** * Current state of the queue * * @type {string} * @private */ #state; /** * Number of callbacks currently running * * @type {number} * @private */ #concurrent; /** * Queue configuration options * * @type {QueueOptions} * @private */ #options; /** * Creates a new concurrent callback queue. * * @param {QueueOptions} options - Queue configuration options. */ constructor(options = defaultQueueOptions) { this.#pending = []; this.#running = new Map(); this.#state = QueueState.IDLE; this.#concurrent = 0; this.#initOptions(options); } /** * Empty function used as a default callback. * * @returns {void} * @private */ #noop = () =&gt; { }; /** * Initializes the queue configuration options, merging the default options with the received options. * * @param {QueueOptions} options - Queue configuration options. */ #initOptions(options) { this.#options = { ...defaultQueueOptions, ...options, }; // Set a noop for unspecified callbacks to avoid checking if they are functions in each call this.#options.onCallbackError = typeof options.onCallbackError === 'function' ? options.onCallbackError : this.#noop; this.#options.onCallbackSuccess = typeof options.onCallbackSuccess === 'function' ? options.onCallbackSuccess : this.#noop; this.#options.onQueueIdle = typeof options.onQueueIdle === 'function' ? options.onQueueIdle : this.#noop; this.#options.onQueueBusy = typeof options.onQueueBusy === 'function' ? options.onQueueBusy : this.#noop; this.#options.onQueueStop = typeof options.onQueueStop === 'function' ? options.onQueueStop : this.#noop; } /** * Adds a callback to the queue, if autoStart is enabled the queue execution starts. * You can specify an optional number of retries in case of an error. * * @param {Function} callback - The callback function to add to the queue. * @param {number} [retries=0] - Number of retry attempts in case of an error (optional). * @returns {void} * @throws {Error} If the callback is not a function or retries is not a number. * * @public */ enqueue(callback, retries = 0) { if (typeof callback !== 'function') { throw new Error('The \"callback\" parameter must be a function or a promise'); } if (typeof retries !== 'number' || retries &lt; 0) { throw new Error('The \"retries\" parameter must be a positive number'); } const retryCallback = async (currentRetry) =&gt; { try { await callback(); } catch (error) { if (currentRetry &lt; retries) { console.warn(`Error executing callback. Retrying (${currentRetry + 1}/${retries})...`); await retryCallback(currentRetry + 1); } else { this.#handleError(error); } } }; this.#pending.push(() =&gt; retryCallback(0)); if (this.#options.autoStart) { this.start(); } } /** * Adds multiple callbacks to the queue, if autoStart is enabled the queue execution starts. * You can specify an optional number of retry attempts in case of an error. * * @param {Array&lt;Function&gt;} callbacks - The array of callback functions to add to the queue. * @param {number} [retries=0] - Number of retry attempts in case of an error for all callbacks (optional). * @returns {void} * @throws {Error} If callbacks is not an array of functions or retries is not a number. * * @public */ enqueueAll(callbacks, retries = 0) { if (!Array.isArray(callbacks) || !callbacks.every(callback =&gt; typeof callback === 'function')) { throw new Error('The \"callbacks\" parameter must be an array of functions'); } if (typeof retries !== 'number' || retries &lt; 0) { throw new Error('The \"retries\" parameter must be a positive number'); } const retryCallbacks = callbacks.map(callback =&gt; { const retryCallback = async (currentRetry) =&gt; { try { await callback(); } catch (error) { if (currentRetry &lt; retries) { console.warn(`Error executing callback. Retrying (${currentRetry + 1}/${retries})...`); await retryCallback(currentRetry + 1); } else { this.#handleError(error); } } }; return () =&gt; retryCallback(0); }); this.#pending.push(...retryCallbacks); if (this.#options.autoStart) { this.start(); } } /** * Starts the execution of the queue. * * If the queue is stopped at any point and then restarted, * the execution resumes from the last pending callback. * * @returns {void} * @public */ start() { if (this.#state === QueueState.BUSY || this.#pending.length === 0) { return; } this.#state = QueueState.BUSY; this.#processIfNecessary(); } /** * Executes the callbacks in the queue concurrently. * * @returns {void} * @private */ #process() { while (this.#shouldProcess()) { const callback = this.#pending.shift(); this.#concurrent++; const index = Date.now(); this.#running.set(index, callback); Promise.resolve() .then(() =&gt; callback()) .then(() =&gt; this.#options.onCallbackSuccess()) .catch((error) =&gt; this.#handleError(error)) .finally(() =&gt; { this.#concurrent--; this.#running.delete(index); this.#processIfNecessary(); }); } // Check if the queue is now idle or busy if (this.#state === QueueState.IDLE) { this.#options.onQueueIdle(); } else if (this.#state === QueueState.BUSY) { this.#options.onQueueBusy(); } else if (this.#state === QueueState.STOPPED) { this.#options.onQueueStop(); } } /** * Handles errors that occur during the execution of a callback. * * @param {Error} error - The error object. * @returns {void} * @private */ #handleError(error) { this.#options.onCallbackError(error); } /** * Determines if the queue should be processed * * @returns {boolean} True if the queue should be processed, false otherwise * @private */ #shouldProcess() { return this.#state === QueueState.BUSY &amp;&amp; this.#concurrent &lt; this.#options.maxConcurrent &amp;&amp; this.#pending.length &gt; 0; } /** * Checks the state of the queue and processes it if necessary. * * @returns {void} * @private */ #processIfNecessary() { if (this.#state === QueueState.BUSY) { if (this.#pending.length &gt; 0) { this.#process(); } else if (this.#concurrent === 0) { this.stop(); } } } /** * Stops the execution of the queue, but does not remove pending callbacks. * * Calling this method will not stop the execution of callbacks that are already being processed, * nor will it remove pending callbacks from the queue, so if the queue is restarted, * it will resume from the last pending callback. * * @returns {void} * @public */ stop() { this.#state = QueueState.IDLE; } /** * Stops the execution of the queue and removes all callbacks from it. * * @returns {Array&lt;Function&gt;} List of pending callbacks * @public */ clear() { this.stop(); return this.dequeueAll(); } /** * Removes a pending callback from the queue without stopping the queue execution. * * @return {Function} Removed callback * @public */ dequeue() { return this.#pending.shift(); } /** * Removes all pending callbacks from the queue without stopping the queue execution. * * @returns {Array&lt;Function&gt;} List of pending callbacks * @public */ dequeueAll() { const queue = this.#pending; this.#pending = []; return queue; } /** * Returns the current state of the queue. * * @returns {string} */ getState() { return this.#state; } } Ã— Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions Global Members &lt;constant&gt; QueueState :Object Enumerates the states the queue can be in. Enumerates the states the queue can be in Type: Object Source: ConcurrentCallbackQueue.js, line 36 &lt;constant&gt; defaultQueueOptions :QueueOptions Default queue options. Default queue options Type: QueueOptions Source: ConcurrentCallbackQueue.js, line 21 Type Definitions QueueOptions Queue configuration options. Queue configuration options Type: Object Properties: Name Type Description autoStart boolean Indicates if the queue should start execution automatically when a callback is added maxConcurrent number Maximum number of callbacks that can be executed in parallel onCallbackError function Callback that is executed when an error occurs while executing a callback, receives the error as a parameter onCallbackSuccess function Callback that is executed after a callback successfully executes onQueueIdle function Callback that is executed when the queue goes to IDLE state onQueueBusy function Callback that is executed when the queue goes to BUSY state onQueueStop function Callback that is executed when the queue stops Source: ConcurrentCallbackQueue.js, line 3 Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions Classes Classes ConcurrentCallbackQueue Concurrent callback queue. ConcurrentCallbackQueue Creates a new concurrent callback queue. Members &lt;constant&gt; QueueState :Object Enumerates the states the queue can be in. Enumerates the states the queue can be in Type: Object Source: ConcurrentCallbackQueue.js, line 36 &lt;constant&gt; defaultQueueOptions :QueueOptions Default queue options. Default queue options Type: QueueOptions Source: ConcurrentCallbackQueue.js, line 21 Type Definitions QueueOptions Queue configuration options. Queue configuration options Type: Object Properties: Name Type Description autoStart boolean Indicates if the queue should start execution automatically when a callback is added maxConcurrent number Maximum number of callbacks that can be executed in parallel onCallbackError function Callback that is executed when an error occurs while executing a callback, receives the error as a parameter onCallbackSuccess function Callback that is executed after a callback successfully executes onQueueIdle function Callback that is executed when the queue goes to IDLE state onQueueBusy function Callback that is executed when the queue goes to BUSY state onQueueStop function Callback that is executed when the queue stops Source: ConcurrentCallbackQueue.js, line 3 Ã— Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions Tutorials Classes ConcurrentCallbackQueue Concurrent callback queue. ConcurrentCallbackQueue Creates a new concurrent callback queue. Members &lt;constant&gt; QueueState :Object Enumerates the states the queue can be in. Enumerates the states the queue can be in Type: Object Source: ConcurrentCallbackQueue.js, line 36 &lt;constant&gt; defaultQueueOptions :QueueOptions Default queue options. Default queue options Type: QueueOptions Source: ConcurrentCallbackQueue.js, line 21 Type Definitions QueueOptions Queue configuration options. Queue configuration options Type: Object Properties: Name Type Description autoStart boolean Indicates if the queue should start execution automatically when a callback is added maxConcurrent number Maximum number of callbacks that can be executed in parallel onCallbackError function Callback that is executed when an error occurs while executing a callback, receives the error as a parameter onCallbackSuccess function Callback that is executed after a callback successfully executes onQueueIdle function Callback that is executed when the queue goes to IDLE state onQueueBusy function Callback that is executed when the queue goes to BUSY state onQueueStop function Callback that is executed when the queue stops Source: ConcurrentCallbackQueue.js, line 3 Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions concurrent_callback_queue 0.8.0 Concurrent Callback Queue This JavaScript module provides a concurrent callback queue that allows you to manage and execute multiple callbacks concurrently with various configuration options. The queue ensures controlled execution of the callbacks with options for handling errors, managing concurrency levels, and defining custom behavior on different queue states. Features Concurrent Execution: Execute multiple callbacks concurrently with a configurable limit on the number of concurrent executions. Automatic Start: Option to automatically start the queue execution upon adding a callback. Retry Mechanism: Define the number of retry attempts for each callback in case of errors. State Management: Callbacks for different queue states (idle, busy, stopped) and events (success, error). Custom Callbacks: Customize behavior on callback success, error, and different queue states. Installation To use the ConcurrentCallbackQueue, you can directly include the JavaScript file in your project. &lt;script src=\"path/to/ConcurrentCallbackQueue.js\"&gt;&lt;/script&gt; Or, if you're using a module bundler, you can import it: import ConcurrentCallbackQueue from './path/to/ConcurrentCallbackQueue.js'; Usage Example Here's an example of how to use the ConcurrentCallbackQueue: const queue = new ConcurrentCallbackQueue({ autoStart: false, maxConcurrent: 2, onCallbackError: (error) =&gt; console.error(error), }); for (let i = 0; i &lt; 10; i++) { queue.enqueue(() =&gt; { const uri = 'https://httpstat.us/200,400?sleep=2000'; return $.get(uri).done(() =&gt; { console.log(`Request ${i+1} completed`); }); }, 3); } queue.start(); More detailed examples can be found in the tutorial page. Configuration Options The queue can be configured with the following options: autoStart (boolean): Whether to start the queue automatically when a callback is added. maxConcurrent (number): Maximum number of callbacks to execute concurrently. onCallbackError (function): Callback executed when an error occurs during callback execution. onCallbackSuccess (function): Callback executed after a callback is executed successfully. onQueueIdle (function): Callback executed when the queue becomes idle. onQueueBusy (function): Callback executed when the queue becomes busy. onQueueStop (function): Callback executed when the queue stops. API enqueue(callback, retries = 0) Adds a callback to the queue. If autoStart is enabled, it starts the queue. callback (function): The callback function to be added to the queue. retries (number, optional): Number of retry attempts in case of error. enqueueAll(callbacks, retries = 0) Adds multiple callbacks to the queue. If autoStart is enabled, it starts the queue. callbacks (Array): An array of callback functions to be added to the queue. retries (number, optional): Number of retry attempts for all callbacks in case of error. start() Starts the execution of the queue. Resumes execution if the queue was stopped. stop() Stops the execution of the queue without clearing the pending callbacks. clear() Stops the execution of the queue and clears all pending callbacks. dequeue() Removes a pending callback from the queue without stopping the queue execution. dequeueAll() Removes all pending callbacks from the queue without stopping the queue execution. getState() Returns the current state of the queue. Queue States IDLE: The queue is idle. BUSY: The queue is busy executing callbacks. STOPPED: The queue is stopped. License This project is licensed under the MIT License. Author David Urbina Ã— Search results Close "},"ConcurrentCallbackQueue.html":{"id":"ConcurrentCallbackQueue.html","title":"Class: ConcurrentCallbackQueue","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions Class: ConcurrentCallbackQueue ConcurrentCallbackQueue new ConcurrentCallbackQueue() Concurrent callback queue. Concurrent callback queue Version: 0.8.0 Since: 2023-03-23 Author: David Urbina (davidurbina.dev@gmail.com) Source: ConcurrentCallbackQueue.js, line 42 Tutorials: concurrent-callback-queue Example const queue = new ConcurrentCallbackQueue({ autoStart: false, maxConcurrent: 2, onCallbackError: (error) =&gt; console.error(error), }); for (let i = 0; i &lt; 10; i++) { queue.enqueue(() =&gt; { const uri = 'https://httpstat.us/200,400?sleep=2000'; return $.get(uri).done(() =&gt; { console.log(`Request ${i+1} completed`); }); }, 3); } queue.start(); Methods clear() Stops the execution of the queue and removes all callbacks from it. Stops the execution of the queue and removes all callbacks from it. Source: ConcurrentCallbackQueue.js, line 345 Returns: List of pending callbacks Type Array.&lt;function()&gt; dequeue() Removes a pending callback from the queue without stopping the queue execution. Removes a pending callback from the queue without stopping the queue execution. Source: ConcurrentCallbackQueue.js, line 356 Returns: Removed callback Type function dequeueAll() Removes all pending callbacks from the queue without stopping the queue execution. Removes all pending callbacks from the queue without stopping the queue execution. Source: ConcurrentCallbackQueue.js, line 366 Returns: List of pending callbacks Type Array.&lt;function()&gt; enqueue(callback [, retries]) Adds a callback to the queue, if autoStart is enabled the queue execution starts. Adds a callback to the queue, if autoStart is enabled the queue execution starts. You can specify an optional number of retries in case of an error. Parameters: Name Type Argument Default Description callback function The callback function to add to the queue. retries number &lt;optional&gt; 0 Number of retry attempts in case of an error (optional). Source: ConcurrentCallbackQueue.js, line 162 Throws: If the callback is not a function or retries is not a number. Type Error Returns: Type void enqueueAll(callbacks [, retries]) Adds multiple callbacks to the queue, if autoStart is enabled the queue execution starts. Adds multiple callbacks to the queue, if autoStart is enabled the queue execution starts. You can specify an optional number of retry attempts in case of an error. Parameters: Name Type Argument Default Description callbacks Array.&lt;function()&gt; The array of callback functions to add to the queue. retries number &lt;optional&gt; 0 Number of retry attempts in case of an error for all callbacks (optional). Source: ConcurrentCallbackQueue.js, line 201 Throws: If callbacks is not an array of functions or retries is not a number. Type Error Returns: Type void getState() Returns the current state of the queue. Returns the current state of the queue. Source: ConcurrentCallbackQueue.js, line 377 Returns: Type string start() Starts the execution of the queue. Starts the execution of the queue. If the queue is stopped at any point and then restarted, the execution resumes from the last pending callback. Source: ConcurrentCallbackQueue.js, line 243 Returns: Type void stop() Stops the execution of the queue, but does not remove pending callbacks. Stops the execution of the queue, but does not remove pending callbacks. Calling this method will not stop the execution of callbacks that are already being processed, nor will it remove pending callbacks from the queue, so if the queue is restarted, it will resume from the last pending callback. Source: ConcurrentCallbackQueue.js, line 335 Returns: Type void Class: ConcurrentCallbackQueue ConcurrentCallbackQueue new ConcurrentCallbackQueue(options) Creates a new concurrent callback queue. Creates a new concurrent callback queue. Parameters: Name Type Description options QueueOptions Queue configuration options. Source: ConcurrentCallbackQueue.js, line 115 Methods clear() Stops the execution of the queue and removes all callbacks from it. Stops the execution of the queue and removes all callbacks from it. Source: ConcurrentCallbackQueue.js, line 345 Returns: List of pending callbacks Type Array.&lt;function()&gt; dequeue() Removes a pending callback from the queue without stopping the queue execution. Removes a pending callback from the queue without stopping the queue execution. Source: ConcurrentCallbackQueue.js, line 356 Returns: Removed callback Type function dequeueAll() Removes all pending callbacks from the queue without stopping the queue execution. Removes all pending callbacks from the queue without stopping the queue execution. Source: ConcurrentCallbackQueue.js, line 366 Returns: List of pending callbacks Type Array.&lt;function()&gt; enqueue(callback [, retries]) Adds a callback to the queue, if autoStart is enabled the queue execution starts. Adds a callback to the queue, if autoStart is enabled the queue execution starts. You can specify an optional number of retries in case of an error. Parameters: Name Type Argument Default Description callback function The callback function to add to the queue. retries number &lt;optional&gt; 0 Number of retry attempts in case of an error (optional). Source: ConcurrentCallbackQueue.js, line 162 Throws: If the callback is not a function or retries is not a number. Type Error Returns: Type void enqueueAll(callbacks [, retries]) Adds multiple callbacks to the queue, if autoStart is enabled the queue execution starts. Adds multiple callbacks to the queue, if autoStart is enabled the queue execution starts. You can specify an optional number of retry attempts in case of an error. Parameters: Name Type Argument Default Description callbacks Array.&lt;function()&gt; The array of callback functions to add to the queue. retries number &lt;optional&gt; 0 Number of retry attempts in case of an error for all callbacks (optional). Source: ConcurrentCallbackQueue.js, line 201 Throws: If callbacks is not an array of functions or retries is not a number. Type Error Returns: Type void getState() Returns the current state of the queue. Returns the current state of the queue. Source: ConcurrentCallbackQueue.js, line 377 Returns: Type string start() Starts the execution of the queue. Starts the execution of the queue. If the queue is stopped at any point and then restarted, the execution resumes from the last pending callback. Source: ConcurrentCallbackQueue.js, line 243 Returns: Type void stop() Stops the execution of the queue, but does not remove pending callbacks. Stops the execution of the queue, but does not remove pending callbacks. Calling this method will not stop the execution of callbacks that are already being processed, nor will it remove pending callbacks from the queue, so if the queue is restarted, it will resume from the last pending callback. Source: ConcurrentCallbackQueue.js, line 335 Returns: Type void Ã— Search results Close "},"tutorial-concurrent-callback-queue.html":{"id":"tutorial-concurrent-callback-queue.html","title":"Tutorial: concurrent-callback-queue","body":" Concurrent Callback Queue Classes ConcurrentCallbackQueue Tutorials concurrent-callback-queue Global QueueStatedefaultQueueOptions concurrent-callback-queue Using Concurrent Callback Queue This tutorial will guide you through the steps of using the ConcurrentCallbackQueue to manage and execute callbacks concurrently. Table of Contents Introduction Installation Basic Usage Advanced Configuration Handling Callbacks Queue Management Examples Introduction The ConcurrentCallbackQueue is a powerful utility for managing the execution of multiple callbacks concurrently. It allows you to control the number of concurrent executions, handle errors, and define custom behaviors for various queue states. Installation Script Tag You can include the ConcurrentCallbackQueue.js file directly in your HTML: &lt;script src=\"path/to/ConcurrentCallbackQueue.js\"&gt;&lt;/script&gt; Module Import If you are using a module bundler like Webpack or a module-based project setup, you can import it: import ConcurrentCallbackQueue from './path/to/ConcurrentCallbackQueue.js'; Basic Usage Creating a Queue To create a queue, simply instantiate the ConcurrentCallbackQueue class: const queue = new ConcurrentCallbackQueue(); Adding Callbacks You can add a callback to the queue using the enqueue method: queue.enqueue(() =&gt; { console.log('Callback executed'); }); Starting the Queue If autoStart is not enabled, you need to start the queue manually: queue.start(); Advanced Configuration The ConcurrentCallbackQueue class can be configured with various options during instantiation: const queue = new ConcurrentCallbackQueue({ autoStart: false, maxConcurrent: 3, onCallbackError: (error) =&gt; console.error('Error:', error), onCallbackSuccess: () =&gt; console.log('Callback succeeded'), onQueueIdle: () =&gt; console.log('Queue is idle'), onQueueBusy: () =&gt; console.log('Queue is busy'), onQueueStop: () =&gt; console.log('Queue stopped'), }); Configuration Options autoStart (boolean): Automatically start the queue when a callback is added. maxConcurrent (number): Maximum number of concurrent executions. onCallbackError (function): Function called on callback error. onCallbackSuccess (function): Function called on callback success. onQueueIdle (function): Function called when the queue is idle. onQueueBusy (function): Function called when the queue is busy. onQueueStop (function): Function called when the queue stops. Handling Callbacks Adding Callbacks with Retries You can specify the number of retries for a callback in case of errors: queue.enqueue(() =&gt; { // Callback code }, 3); Adding Multiple Callbacks You can add multiple callbacks at once using enqueueAll: const callbacks = [ () =&gt; console.log('Callback 1'), () =&gt; console.log('Callback 2'), ]; queue.enqueueAll(callbacks, 2); Queue Management Starting the Queue To start the queue manually: queue.start(); Stopping the Queue To stop the queue without clearing the pending callbacks: queue.stop(); Clearing the Queue To stop the queue and clear all pending callbacks: queue.clear(); Removing Callbacks To remove a single pending callback: queue.dequeue(); To remove all pending callbacks: queue.dequeueAll(); Examples Example 1: Basic Usage const queue = new ConcurrentCallbackQueue({ autoStart: true, maxConcurrent: 2 }); queue.enqueue(() =&gt; { console.log('Callback 1 executed'); }); queue.enqueue(() =&gt; { console.log('Callback 2 executed'); }); Example 2: Using Callbacks with Retries const queue = new ConcurrentCallbackQueue({ maxConcurrent: 1 }); queue.enqueue(() =&gt; { return new Promise((resolve, reject) =&gt; { // Simulate an async operation setTimeout(() =&gt; { console.log('Callback executed'); resolve(); }, 1000); }); }, 2); queue.start(); Example 3: Handling Callback Success and Error const queue = new ConcurrentCallbackQueue({ onCallbackSuccess: () =&gt; console.log('Callback succeeded'), onCallbackError: (error) =&gt; console.error('Error:', error), }); queue.enqueue(() =&gt; { return new Promise((resolve, reject) =&gt; { // Simulate a callback with an error setTimeout(() =&gt; { reject(new Error('Something went wrong')); }, 1000); }); }); queue.start(); Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
